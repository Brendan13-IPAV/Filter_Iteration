<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IP First Response 2.0</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Additional styles for cost and effort display */
    .card-metrics {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .metric-row {
      margin-bottom: 4px;
      display: flex;
      align-items: center;
    }
    
    .metric-label {
      font-weight: 500;
      margin-right: 8px;
      min-width: 100px;
    }
    
    .metric-value {
      color: var(--text-primary);
      flex: 1;
    }

    /* Tag sections wrapper */
    .tag-sections {
      margin-top: 12px;
      border-top: 1px solid var(--border-color);
      padding-top: 12px;
    }

    /* Tighter spacing for tag rows */
    .tag-row {
      margin-bottom: 2px;
    }
    
    /* Last tag row has no margin */
    .tag-row:last-child {
      margin-bottom: 0;
    }

    /* New styles for IP type and approach tags */
    .strategy-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      flex: 1;
    }

    .strategy-tag {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      font-weight: 500;
    }

    /* Using the colors from styles.css */
    .tag-ip-any {
      background-color: rgba(102, 112, 133, 0.1);
      color: var(--any-color);
    }
    
    .tag-ip-patent {
      background-color: rgba(29, 167, 175, 0.1);
      color: var(--patent-color);
    }
    
    .tag-ip-trademark, .tag-ip-trademarkt {
      background-color: rgba(222, 67, 38, 0.1);
      color: var(--trademark-color);
    }
    
    .tag-ip-design {
      background-color: rgba(132, 201, 143, 0.1);
      color: var(--design-color);
    }
    
    .tag-ip-copyright {
      background-color: rgba(120, 122, 187, 0.1);
      color: var(--copyright-color);
    }
    
    .tag-ip-pbr {
      background-color: rgba(241, 172, 30, 0.1);
      color: var(--pbr-color);
    }

    .tag-approach {
      background-color: rgba(85, 171, 201, 0.1);
      color: var(--teal);
    }

    /* Not applicable styling */
    .not-applicable {
      opacity: 0.7;
    }

    .not-applicable-badge {
      background-color: #f5f5f5;
      color: #616161;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header-content">
        <div class="logo">IP First Response 2.0</div>
        <nav class="nav">
          <a href="index.html">Home</a>
          <a href="#">About</a>
        </nav>
      </div>
    </div>
  </header>

  <div class="container main-content">
    <div id="app">Loading... Please wait while we prepare your options</div>
  </div>

  <footer class="footer">
    <div class="container">
      <p style="text-align: center; font-size: 14px;">&copy; 2025 IP Strategy Finder</p>
    </div>
  </footer>

  <script>
    Promise.all([
      fetch('strategies.json').then(res => res.json()),
      fetch('preferences.json').then(res => res.json()),
      fetch('scoring-matrix.json').then(res => res.json()) // New JSON file for scoring matrix
    ]).then(([strategiesData, preferenceConfigs, scoringMatrix]) => {
      // Make preferenceConfigs globally available for use in filtering functions
      window.preferenceConfigs = preferenceConfigs;

      const ipRightsOptions = [
        { id: 'Patent', label: 'Patents', color: 'patent' },
        { id: 'Trade mark', label: 'Trade marks', color: 'trademark' },
        { id: 'Design', label: 'Design rights', color: 'design' },
        { id: 'PBR', label: "Plant breeder's rights", color: 'pbr' },
        { id: 'Copyright', label: 'Copyright', color: 'copyright' },
        { id: 'Any', label: 'Any IP right', color: 'any' }
      ];

      const situationOptions = [
        { id: 'Accused', label: "I've been accused of infringing" },
        { id: 'Enforcement', label: 'I believe my IP has been infringed' },
        { id: 'Proactive', label: "I'm proactively protecting my IP" },
        { id: 'Professional', label: "I'm seeking support of an IP professional" }
      ];

      function IPStrategyFinder() {
        // Get only the primary filters from localStorage (rights and situations)
        const savedState = JSON.parse(localStorage.getItem('ipStrategyState')) || {};
        
        // Check if coming from index page with new selections
        const selectedFromIndex = JSON.parse(localStorage.getItem('ipSelectedRights'));
        
        // Define all possible rights for use as default
        const allRights = ['Patent', 'Trade mark', 'Design', 'PBR', 'Copyright', 'Any'];
        
        const state = {
          loading: true,
          strategies: strategiesData,
          filteredStrategies: [],
          accordions: savedState.accordions || { 
            preferences: true, 
            otherFactors: true, 
            situationFilters: true, 
            ipTypeFilters: true 
          },
          // Use selections from index.html if available, otherwise use saved state or ALL rights
          selectedRights: selectedFromIndex || savedState.selectedRights || allRights,
          selectedSituations: savedState.selectedSituations || ['Enforcement'],
          // Don't load preferences and otherFactors from localStorage - always start fresh
          preferences: {
            timeCommitment: 0,
            investment: 0,
            commercialAgreements: 0,
            thirdPartyServices: 0,
            legalAction: 0
          },
          otherFactors: {
            onlineMarkets: 'neutral',
            domainName: 'neutral',
            importingGoods: 'neutral',
            identifyParty: 'neutral'
          },
          // New properties for situation and IP specific filters
          situationSpecificFilters: {},
          ipTypeSpecificFilters: {}
        };
        
        // Clear the selection from localStorage to avoid affecting future visits
        localStorage.removeItem('ipSelectedRights');

        function init() {
          state.loading = false;
          state.filteredStrategies = calculateStrategyScores(
            state.strategies,
            state,
            scoringMatrix
          );
const filterGroups = {
  "Your IP": ["Juristiction", "YourTMStatus", "YourPatStatus"],
  "Costs": ["investment", "thirdPartyServices"],
  "Risks": ["legalAction"],
  "Resolution Preferences": ["domainName", "onlineMarkets", "importingGoods", "identifyParty"]
};

          render();
        }

        // Create a dynamic title based on selected situation and IP right
        function createDynamicTitle() {
          const situationMap = {
            'Enforcement': 'enforce',
            'Accused': 'respond to accusations about',
            'Proactive': 'proactively protect',
            'Professional': 'seek professional support for'
          };
          
          let action = 'manage'; // Default
          if (state.selectedSituations.length === 1) {
            action = situationMap[state.selectedSituations[0]];
          }
          
          let rightText = 'intellectual property';
          
          if (state.selectedRights.length === 1) {
            // Just one right selected
            rightText = `a ${state.selectedRights[0].toLowerCase()}`;
          } else if (state.selectedRights.length > 1) {
            // Multiple rights selected - format them more naturally
            if (state.selectedRights.length === 2) {
              // Two rights - use "and" between them
              rightText = `${state.selectedRights[0].toLowerCase()} and ${state.selectedRights[1].toLowerCase()}`;
            } else if (state.selectedRights.length <= 4) {
              // 3-4 rights - list with commas and "and"
              const lastRight = state.selectedRights[state.selectedRights.length - 1].toLowerCase();
              const otherRights = state.selectedRights.slice(0, -1).map(r => r.toLowerCase());
              rightText = `${otherRights.join(', ')} and ${lastRight}`;
            } else {
              // More than 4 rights - keep it simple
              rightText = 'multiple IP rights';
            }
          }
          
          return `Showing: Strategies to ${action} ${rightText}`;
        }

        function render() {
          // Only save primary filters to localStorage
          localStorage.setItem('ipStrategyState', JSON.stringify({
            accordions: state.accordions,
            selectedRights: state.selectedRights,
            selectedSituations: state.selectedSituations
            // Do not save preferences or otherFactors
          }));

          const app = document.getElementById('app');
          app.innerHTML = '';

          const container = document.createElement('div');
          container.className = 'grid';

          const leftCol = document.createElement('div');
                          // leftCol.appendChild(renderTopPreferences()); // Move specific preferences outside accordion
                          // leftCol.appendChild(renderPreferencesAccordion());
                          // leftCol.appendChild(renderSituationSpecificFilters()); // New situation filters
                          // leftCol.appendChild(renderIPTypeSpecificFilters()); // New IP type filters
                          // leftCol.appendChild(renderOtherFactorsAccordion());
          // Example of rendering your custom filter groupings
leftCol.appendChild(renderCustomAccordion("Your trade mark", ["Juristiction", "YourTMStatus"]));
leftCol.appendChild(renderCustomAccordion("Your patent", ["YourPatStatus", "thirdPartyServices"]));
leftCol.appendChild(renderCustomAccordion("Risks", ["legalAction"]));
leftCol.appendChild(renderCustomAccordion("Resolution Preferences", ["domainName", "onlineMarkets", "importingGoods", "identifyParty"], 'otherFactors'));

          //  Heres how you make specific combis base don input
          //if (state.selectedSituations.includes("Enforcement")) {
          //  leftCol.appendChild(renderCustomAccordion("Risks", ["legalAction"]));
          //       }

          container.appendChild(leftCol);

          const rightCol = document.createElement('div');
          rightCol.appendChild(renderActiveFilters()); // Contains title and clear button
          rightCol.appendChild(renderStrategyCards());
          container.appendChild(rightCol);

          app.appendChild(container);
        }

        // Render Commercial Agreements and Legal Action outside accordion
        function renderTopPreferences() {
          const topPrefs = document.createElement('div');
          topPrefs.className = 'top-preferences';
          topPrefs.style.marginBottom = '20px';
          
          // Add key preferences outside accordion
          const keysToInclude = ['commercialAgreements', 'legalAction'];
          
          keysToInclude.forEach(key => {
            const config = preferenceConfigs.filters[key]; // Use the nested structure
            
            const group = document.createElement('div');
            group.className = 'preference-group';

            const label = document.createElement('label');
            label.className = 'preference-label';
            label.textContent = config.label;
            group.appendChild(label);

            const radioGroup = document.createElement('div');
            radioGroup.className = 'radio-group';
            
            config.options.forEach(opt => {
              const radio = document.createElement('label');
              radio.className = 'radio-button';
              if (state.preferences[key] === opt.value) {
                radio.classList.add('radio-selected');
              }
              radio.classList.add('radio-option');
              radio.onclick = function () {
                const alreadySelected = state.preferences[key] === opt.value;
                state.preferences[key] = alreadySelected ? 0 : opt.value;

                // Recalculate using external scoring
                state.filteredStrategies = calculateStrategyScores(
                  state.strategies,
                  state,
                  scoringMatrix
                );

                render();
              };
              radio.appendChild(document.createTextNode(opt.label));

              radioGroup.appendChild(radio);
            });
            
            group.appendChild(radioGroup);
            topPrefs.appendChild(group);
          });
          
          return topPrefs;
        }

        // Replace the existing renderActiveFilters function with this improved version
        function renderActiveFilters() {
          const filtersWrapper = document.createElement('div');
          
          // Create dynamic title and clear button container
          const titleContainer = document.createElement('div');
          titleContainer.style.display = 'flex';
          titleContainer.style.justifyContent = 'space-between';
          titleContainer.style.alignItems = 'center';
          titleContainer.style.marginBottom = '20px';
          
          // Create title based on selected rights and situation
          const titleElement = document.createElement('h2');
          titleElement.className = 'page-title';
          titleElement.textContent = createDynamicTitle();
          titleContainer.appendChild(titleElement);
          
          // Add Clear All Filters button
          const resetBtn = document.createElement('button');
          resetBtn.textContent = 'Clear All Filters';
          resetBtn.className = 'reset-button';
          resetBtn.onclick = () => {
            // Reset all non-primary filters
            state.preferences = {
              timeCommitment: 0,
              investment: 0,
              commercialAgreements: 0,
              thirdPartyServices: 0,
              legalAction: 0
            };
            state.otherFactors = {
              onlineMarkets: 'neutral',
              domainName: 'neutral',
              importingGoods: 'neutral',
              identifyParty: 'neutral'
            };
            // Also reset situation-specific and IP-type specific filters if you've added them
            state.situationSpecificFilters = {};
            state.ipTypeSpecificFilters = {};
            state.filteredStrategies = calculateStrategyScores(
              state.strategies,
              state,
              scoringMatrix
            );

            render();
          };
          titleContainer.appendChild(resetBtn);
          
          filtersWrapper.appendChild(titleContainer);
          
          // Create secondary filters section (if any exist)
          const hasSecondaryFilters = Object.values(state.preferences).some(v => v !== 0) || 
                                    Object.values(state.otherFactors).some(v => v !== 'neutral');
          
          if (hasSecondaryFilters) {
            const secondaryFiltersTitle = document.createElement('div');
            secondaryFiltersTitle.className = 'filters-section-title';
            secondaryFiltersTitle.textContent = 'Active Filters';
            filtersWrapper.appendChild(secondaryFiltersTitle);
            
            const secondaryFiltersContainer = document.createElement('div');
            secondaryFiltersContainer.className = 'active-filters';
            
            // Add preference filters
            Object.entries(state.preferences).forEach(([key, value]) => {
              if (value !== 0) {
                const config = preferenceConfigs.filters[key];
                const opt = config.options.find(o => o.label === value);
                
                // Use pillTemplate and pillLabel for better display
                let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                
                const pill = document.createElement('div');
                pill.className = 'filter-pill';
                pill.textContent = pillText;
                
                const remove = document.createElement('span');
                remove.className = 'filter-remove';
                remove.textContent = '×';
                remove.onclick = () => {
                  state.preferences[key] = 0;
                  state.filteredStrategies = calculateStrategyScores(
                    state.strategies,
                    state,
                    scoringMatrix
                  );

                  render();
                };
                pill.appendChild(remove);
                secondaryFiltersContainer.appendChild(pill);
              }
            });
            
            // Add other factors filters
            Object.entries(state.otherFactors).forEach(([key, value]) => {
              if (value !== 'neutral') {
                const config = preferenceConfigs.otherFactors[key];
                const opt = config.options.find(o => o.label === value);
                
                // Use pillTemplate and pillLabel for better display
                let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                
                const pill = document.createElement('div');
                pill.className = 'filter-pill';
                pill.textContent = pillText;
                
                const remove = document.createElement('span');
                remove.className = 'filter-remove';
                remove.textContent = '×';
                remove.onclick = () => {
                  state.otherFactors[key] = 'neutral';
                  state.filteredStrategies = calculateStrategyScores(
                    state.strategies,
                    state,
                    scoringMatrix
                  );

                  render();
                };
                pill.appendChild(remove);
                secondaryFiltersContainer.appendChild(pill);
              }
            });
            
            // Add situation-specific filters
            if (state.situationSpecificFilters && Object.keys(state.situationSpecificFilters).length > 0) {
              Object.entries(state.situationSpecificFilters).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                  // Find which situation this belongs to
                  let situationFound = false;
                  
                  // Check all situations until we find the one containing this filter
                  for (const situation of state.selectedSituations) {
                    if (preferenceConfigs.situationSpecific[situation] && 
                        preferenceConfigs.situationSpecific[situation][key]) {
                      
                      const config = preferenceConfigs.situationSpecific[situation][key];
                      const opt = config.options.find(o => o.label === value);
                      
                      // Use pillTemplate and pillLabel for better display
                      let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                      pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                      
                      const pill = document.createElement('div');
                      pill.className = 'filter-pill';
                      pill.textContent = pillText;
                      
                      const remove = document.createElement('span');
                      remove.className = 'filter-remove';
                      remove.textContent = '×';
                      remove.onclick = () => {
                        delete state.situationSpecificFilters[key];
                        state.filteredStrategies = calculateStrategyScores(
                          state.strategies,
                          state,
                          scoringMatrix
                        );

                        render();
                      };
                      pill.appendChild(remove);
                      secondaryFiltersContainer.appendChild(pill);
                      
                      situationFound = true;
                      break;
                    }
                  }
                }
              });
            }
            
            // Add IP-specific filters
            if (state.ipTypeSpecificFilters && Object.keys(state.ipTypeSpecificFilters).length > 0) {
              Object.entries(state.ipTypeSpecificFilters).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                  // Find which IP type this belongs to
                  let ipTypeFound = false;
                  
                  // Check all IP types until we find the one containing this filter
                  for (const ipType of state.selectedRights) {
                    if (preferenceConfigs.ipTypeSpecific[ipType] && 
                        preferenceConfigs.ipTypeSpecific[ipType][key]) {
                      
                      const config = preferenceConfigs.ipTypeSpecific[ipType][key];
                      const opt = config.options.find(o => o.label === value);
                      
                      // Use pillTemplate and pillLabel for better display
                      let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                      pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                      
                      const pill = document.createElement('div');
                      pill.className = 'filter-pill';
                      pill.textContent = pillText;
                      
                      const remove = document.createElement('span');
                      remove.className = 'filter-remove';
                      remove.textContent = '×';
                      remove.onclick = () => {
                        delete state.ipTypeSpecificFilters[key];
                        state.filteredStrategies = calculateStrategyScores(
                          state.strategies,
                          state,
                          scoringMatrix
                        );

                        render();
                      };
                      pill.appendChild(remove);
                      secondaryFiltersContainer.appendChild(pill);
                      
                      ipTypeFound = true;
                      break;
                    }
                  }
                }
              });
            }
            
            filtersWrapper.appendChild(secondaryFiltersContainer);
          }
          
          return filtersWrapper;
        }

        // New function to render IP type specific filters
        function renderIPTypeSpecificFilters() {
          const wrapper = document.createElement('div');

          // Only show this section if IP types are selected
          if (state.selectedRights.length === 0) {
            return wrapper;
          }
          
          const toggle = document.createElement('div');
          toggle.className = 'accordion-header';
          toggle.style.cursor = 'pointer';
          toggle.innerHTML = '<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ' + (state.accordions.ipTypeFilters ? 'rotate(90deg)' : 'rotate(0deg)') + ';">▶</span> About the other party';
          toggle.onclick = () => {
            state.accordions.ipTypeFilters = !state.accordions.ipTypeFilters;
            render();
          };
          wrapper.appendChild(toggle);

          if (!state.accordions.ipTypeFilters) return wrapper;

          // Initialize state.ipTypeSpecificFilters if it doesn't exist
          if (!state.ipTypeSpecificFilters) {
            state.ipTypeSpecificFilters = {};
          }

          const accordion = document.createElement('div');
          accordion.className = 'accordion';

          // For each selected IP type, show relevant filters
          state.selectedRights.forEach(ipType => {
            if (preferenceConfigs.ipTypeSpecific && preferenceConfigs.ipTypeSpecific[ipType]) {
              // Add a subheading for the IP type
              const ipTypeHeading = document.createElement('div');
              ipTypeHeading.className = 'preference-group';
              ipTypeHeading.innerHTML = `<h4 style="margin-top: 15px; margin-bottom: 10px;">${ipType}-specific options</h4>`;
              accordion.appendChild(ipTypeHeading);
              
              // Add filters for this IP type
              Object.entries(preferenceConfigs.ipTypeSpecific[ipType]).forEach(([filterKey, config]) => {
                const group = document.createElement('div');
                group.className = 'preference-group';

                const label = document.createElement('label');
                label.className = 'preference-label';
                label.textContent = config.label;
                group.appendChild(label);

                const radioGroup = document.createElement('div');
                radioGroup.className = 'radio-group';
                
                config.options.forEach(opt => {
                  const radio = document.createElement('label');
                  radio.className = 'radio-button';
                  if (state.ipTypeSpecificFilters[filterKey] === opt.value) {
                    radio.classList.add('radio-selected');
                  }
                  radio.textContent = opt.label;
                  radio.onclick = () => {
                    if (state.ipTypeSpecificFilters[filterKey] === opt.value) {
                      // If clicked again, deselect
                      delete state.ipTypeSpecificFilters[filterKey];
                    } else {
                      // Otherwise select
                      state.ipTypeSpecificFilters[filterKey] = opt.value;
                    }
                    state.filteredStrategies = calculateStrategyScores(
                      state.strategies,
                      state,
                      scoringMatrix
                    );

                    render();
                  };
                  radioGroup.appendChild(radio);
                });
                
                group.appendChild(radioGroup);
                accordion.appendChild(group);
              });
            }
          });

          wrapper.appendChild(accordion);
          return wrapper;
        }

        // New function to render situation specific filters
        function renderSituationSpecificFilters() {
          const wrapper = document.createElement('div');

          // Only show this section if situations are selected
          if (state.selectedSituations.length === 0) {
            return wrapper;
          }
          
          const toggle = document.createElement('div');
          toggle.className = 'accordion-header';
          toggle.style.cursor = 'pointer';
          toggle.innerHTML = '<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ' + (state.accordions.situationFilters ? 'rotate(90deg)' : 'rotate(0deg)') + ';">▶</span> About the issue';
          toggle.onclick = () => {
            state.accordions.situationFilters = !state.accordions.situationFilters;
            render();
          };
          wrapper.appendChild(toggle);

          if (!state.accordions.situationFilters) return wrapper;

          // Initialize state.situationSpecificFilters if it doesn't exist
          if (!state.situationSpecificFilters) {
            state.situationSpecificFilters = {};
          }

          const accordion = document.createElement('div');
          accordion.className = 'accordion';

          // For each selected situation, show relevant filters
          state.selectedSituations.forEach(situation => {
            if (preferenceConfigs.situationSpecific && preferenceConfigs.situationSpecific[situation]) {
              // Add a subheading for the situation
              const situationHeading = document.createElement('div');

            situationHeading.className = 'preference-group';
              situationHeading.innerHTML = `<h4 style="margin-top: 15px; margin-bottom: 10px;">${situation}-specific options</h4>`;
              accordion.appendChild(situationHeading);
              
              // Add filters for this situation
              Object.entries(preferenceConfigs.situationSpecific[situation]).forEach(([filterKey, config]) => {
                // Check if this filter should be shown for the selected IP rights
                const shouldShow = !config.showFor || 
                                  state.selectedRights.some(right => config.showFor.includes(right) || config.showFor.includes('Any'));
                
                if (shouldShow) {
                  const group = document.createElement('div');
                  group.className = 'preference-group';

                  const label = document.createElement('label');
                  label.className = 'preference-label';
                  label.textContent = config.label;
                  group.appendChild(label);

                  const radioGroup = document.createElement('div');
                  radioGroup.className = 'radio-group';
                  
                  config.options.forEach(opt => {
                    const radio = document.createElement('label');
                    radio.className = 'radio-button';
                    if (state.situationSpecificFilters[filterKey] === opt.value) {
                      radio.classList.add('radio-selected');
                    }
                    radio.textContent = opt.label;
                    radio.onclick = () => {
                      if (state.situationSpecificFilters[filterKey] === opt.value) {
                        // If clicked again, deselect
                        delete state.situationSpecificFilters[filterKey];
                      } else {
                        // Otherwise select
                        state.situationSpecificFilters[filterKey] = opt.value;
                      }
                      state.filteredStrategies = calculateStrategyScores(
                        state.strategies,
                        state,
                        scoringMatrix
                      );

                      render();
                    };
                    radioGroup.appendChild(radio);
                  });
                  
                  group.appendChild(radioGroup);
                  accordion.appendChild(group);
                }
              });
            }
          });

          wrapper.appendChild(accordion);
          return wrapper;
        }

        // Modification to the renderOtherFactorsAccordion function to support the updated preferences.json
        function renderOtherFactorsAccordion() {
          const wrapper = document.createElement('div');

          const toggle = document.createElement('div');
          toggle.className = 'accordion-header';
          toggle.innerHTML = '<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ' + (state.accordions.otherFactors ? 'rotate(90deg)' : 'rotate(0deg)') + ';">▶</span> Your resolution preferences';
          toggle.onclick = () => {
            state.accordions.otherFactors = !state.accordions.otherFactors;
            render();
          };
          wrapper.appendChild(toggle);

          if (!state.accordions.otherFactors) return wrapper;

          // Get the list of other factors from the updated preferences
          const factors = Object.entries(preferenceConfigs.otherFactors);

          factors.forEach(([key, config]) => {
            // Check if this factor should be shown for the selected IP rights
            const shouldShow = !config.showFor || 
                            state.selectedRights.some(right => config.showFor.includes(right) || config.showFor.includes('Any'));
            
            if (shouldShow) {
              const group = document.createElement('div');
              group.className = 'preference-group';

              const groupLabel = document.createElement('label');
              groupLabel.className = 'preference-label';
              groupLabel.textContent = config.label;
              group.appendChild(groupLabel);

              const radioGroup = document.createElement('div');
              radioGroup.className = 'radio-group';

              config.options.forEach(opt => {
                const radio = document.createElement('label');
                radio.className = 'radio-button';
                if (state.otherFactors[key] === opt.value) {
                  radio.classList.add('radio-selected');
                }
                radio.textContent = opt.label;
                radio.onclick = () => {
                  state.otherFactors[key] = state.otherFactors[key] === opt.value ? 'neutral' : opt.value;
                  state.filteredStrategies = calculateStrategyScores(
                    state.strategies,
                    state,
                    scoringMatrix
                  );

                  render();
                };
                radioGroup.appendChild(radio);
              });

              group.appendChild(radioGroup);
              wrapper.appendChild(group);
            }
          });

          return wrapper;
        }

        function renderPreferencesAccordion() {
          const wrapper = document.createElement('div');

          const toggle = document.createElement('div');
          toggle.className = 'accordion-header';
          toggle.style.cursor = 'pointer';
          toggle.style.transition = 'all 0.3s ease';
          toggle.innerHTML = '<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ' + (state.accordions.preferences ? 'rotate(90deg)' : 'rotate(0deg)') + ';">▶</span> About your IP';
          toggle.onclick = () => {
            state.accordions.preferences = !state.accordions.preferences;
            render();
          };
          wrapper.appendChild(toggle);

          if (!state.accordions.preferences) return wrapper;

          const accordion = document.createElement('div');
          accordion.className = 'accordion';

          // Only show preferences that aren't already shown in top section
          const keysToSkip = ['commercialAgreements', 'legalAction'];
          
          // Iterate through the filters in the new structure
          Object.entries(preferenceConfigs.filters).forEach(([key, config]) => {
            // Skip keys that are already shown in the top section
            if (keysToSkip.includes(key)) return;
            
            const group = document.createElement('div');
            group.className = 'preference-group';

            const label = document.createElement('label');
            label.className = 'preference-label';
            label.textContent = config.label;
            group.appendChild(label);

            const radioGroup = document.createElement('div');
            radioGroup.className = 'radio-group';
            config.options.forEach(opt => {
              const radio = document.createElement('label');
              radio.className = 'radio-button';
              if (state.preferences[key] === opt.value) {
                radio.classList.add('radio-selected');
              }
              radio.textContent = opt.label;
              radio.onclick = () => {
                state.preferences[key] = state.preferences[key] === opt.value ? 0 : opt.value;
                state.filteredStrategies = calculateStrategyScores(
                  state.strategies,
                  state,
                  scoringMatrix
                );

                render();
              };
              radioGroup.appendChild(radio);
            });
            group.appendChild(radioGroup);
            accordion.appendChild(group);
          });

          wrapper.appendChild(accordion);
          return wrapper;
        }

        function renderCustomAccordion(groupLabel, filterKeys, stateSection = 'preferences') {
  const wrapper = document.createElement('div');

  const toggle = document.createElement('div');
  toggle.className = 'accordion-header';
  toggle.innerHTML = `<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ${
    state.accordions[groupLabel] ? 'rotate(90deg)' : 'rotate(0deg)'
  };">▶</span> ${groupLabel}`;
  toggle.onclick = () => {
    state.accordions[groupLabel] = !state.accordions[groupLabel];
    render();
  };
  wrapper.appendChild(toggle);

  if (!state.accordions[groupLabel]) return wrapper;

  const accordion = document.createElement('div');
  accordion.className = 'accordion';

  filterKeys.forEach(key => {
    const config =
      stateSection === 'preferences'
        ? preferenceConfigs.filters[key]
        : preferenceConfigs.otherFactors[key];

    if (!config) return;

    const group = document.createElement('div');
    group.className = 'preference-group';

    const label = document.createElement('label');
    label.className = 'preference-label';
    label.textContent = config.label;
    group.appendChild(label);

    const radioGroup = document.createElement('div');
    radioGroup.className = 'radio-group';

    config.options.forEach(opt => {
      const radio = document.createElement('label');
      radio.className = 'radio-button';
      const currentValue =
        stateSection === 'preferences' ? state.preferences[key] : state.otherFactors[key];

if (currentValue === opt.label) {
        radio.classList.add('radio-selected');
      }

      radio.textContent = opt.label;
      radio.onclick = () => {
if (stateSection === 'preferences') {
  state.preferences[key] = currentValue === opt.label ? 0 : opt.label;
} else {
  state.otherFactors[key] = currentValue === opt.label ? 'neutral' : opt.label;
}


        state.filteredStrategies = calculateStrategyScores(state.strategies, state, scoringMatrix);
        render();
      };

      radioGroup.appendChild(radio);
    });

    group.appendChild(radioGroup);
    accordion.appendChild(group);
  });

  wrapper.appendChild(accordion);
  return wrapper;
}


        // Updated renderStrategyCards function to display IP Type and Approach tags
        function renderStrategyCards() {
          const list = document.createElement('div');
          list.className = 'card-grid';

          const activePrefs = Object.values(state.preferences).filter(v => v !== 0).length;
          const activeFactors = Object.values(state.otherFactors).filter(v => v !== 'neutral').length;
          const showUnknown = (activePrefs + activeFactors) < 2;

          state.filteredStrategies.forEach((strategy, index) => {
            const card = document.createElement('div');
            card.className = 'strategy-card';
            
            // Add not-applicable class if strategy is not applicable
            if (!strategy.isApplicable) {
              card.classList.add('not-applicable');
            }
            
            card.style.opacity = '0';
            card.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
            setTimeout(() => { card.style.opacity = '1'; }, 50 * index); // Staggered animation

            // Determine relevancy based on match score
            let matchLabel = 'Possible';
            let relevanceClass = 'medium'; // mid-green
            const score = strategy.matchScore;
            
            if (!strategy.isApplicable) {
              matchLabel = 'Not Applicable';
              relevanceClass = 'very-low';
            } else if (!showUnknown) {
              if (score >= 90) { matchLabel = 'Highly Likely'; relevanceClass = 'very-high'; }
              else if (score >= 75) { matchLabel = 'Likely'; relevanceClass = 'high'; }
              else if (score >= 50) { matchLabel = 'Possible'; relevanceClass = 'medium'; }
              else if (score >= 25) { matchLabel = 'Unlikely'; relevanceClass = 'low'; }
              else { matchLabel = 'Probably Not-Applicable'; relevanceClass = 'very-low'; }
            }
            
            // Apply the relevancy border color
            card.classList.add(`border-${relevanceClass}`);

            // Get cost, effort and resolution text directly from the JSON
            // Fallback to placeholders if not present in the JSON
            const costText = strategy.costText || "Cost varies based on complexity";
            const effortText = strategy.effortText || "Time requirement varies";
            const resolutionText = strategy.resolutionText || "Success rate varies by case";

            // Start with base HTML content
            let htmlContent = `
              <div class="relevancy">
                <span class="relevancy-label">Applicability:</span>
                <span class="relevancy-badge ${relevanceClass}">${matchLabel}</span>
              </div>
              <div class="strategy-overtitle">${strategy.overtitle}</div>
              <h3 class="strategy-title">${strategy.title}</h3>
              <p class="strategy-description">${strategy.description}</p>
              
              <div class="card-metrics">
                <div class="metric-row">
                  <span class="metric-label">Estimated cost:</span>
                  <span class="metric-value">${costText}</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Estimated effort:</span>
                  <span class="metric-value">${effortText}</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Rate of resolution:</span>
                  <span class="metric-value">${resolutionText}</span>
                </div>
            `;
            
            // Add tag sections underneath the metrics
            const hasIpTypes = strategy.ipTypeTags && strategy.ipTypeTags.length > 0;
            const hasApproaches = strategy.approachTags && strategy.approachTags.length > 0;
            
            // Create tag sections wrapper
            if (hasIpTypes || hasApproaches) {
              htmlContent += '<div class="tag-sections">';
              
              // Add IP type section
              if (hasIpTypes) {
                // Check if "Any" or "Any IP right" or "Any dispute" is included
                const hasAny = strategy.ipTypeTags.some(ipType => 
                  ipType === 'Any' || ipType === 'Any IP right' || ipType === 'Any dispute'
                );
                
                // Filter specific IP types (excluding "Any" or "Any IP right" or "Any dispute")
                const specificIpTypes = strategy.ipTypeTags.filter(ipType => 
                  ipType !== 'Any' && ipType !== 'Any IP right' && ipType !== 'Any dispute'
                );
                
                htmlContent += '<div class="metric-row tag-row">';
                htmlContent += '<span class="metric-label">Specific to:</span>';
                htmlContent += '<div class="strategy-tags">';
                
                if (hasAny) {
                  // Add "Any dispute" tag
                  htmlContent += '<span class="strategy-tag tag-ip-any">Any dispute</span>';
                }
                
                // Add specific IP type tags with different colors
                specificIpTypes.forEach(ipType => {
                  // Convert ipType to a class-friendly format (lowercase, no spaces)
                  const ipClass = ipType.toLowerCase().replace(/\s+/g, '');
                  htmlContent += `<span class="strategy-tag tag-ip-${ipClass}">${ipType}</span>`;
                });
                
                htmlContent += '</div></div>';
              }
              
              // Add approach section
              if (hasApproaches && strategy.approachTags.length > 0) {
                htmlContent += '<div class="metric-row tag-row">';
                htmlContent += '<span class="metric-label">Approach:</span>';
                htmlContent += '<div class="strategy-tags">';
                
                strategy.approachTags.forEach(approach => {
                  htmlContent += `<span class="strategy-tag tag-approach">${approach}</span>`;
                });
                
                htmlContent += '</div></div>';
              }
              
              htmlContent += '</div>'; // Close tag-sections
            }
            
            // Close card-metrics
            htmlContent += '</div>';
            
            // Set the HTML content
            card.innerHTML = htmlContent;
            list.appendChild(card);
          });

          return list;
        }

        return { init };
      }

      const app = IPStrategyFinder();
      app.init();

      // Add "Change IP Rights" link
      const changeIPRightsLink = document.createElement('a');
      changeIPRightsLink.href = 'index.html';
      changeIPRightsLink.textContent = 'Start Over with Different IP Rights';
      changeIPRightsLink.style.color = 'var(--text-secondary)';
      changeIPRightsLink.style.textDecoration = 'none';
      changeIPRightsLink.style.fontSize = '14px';
      changeIPRightsLink.style.display = 'inline-block';
      changeIPRightsLink.style.marginTop = '20px';
      changeIPRightsLink.style.marginBottom = '20px';

      // Add to page above the app
      document.getElementById('app').before(changeIPRightsLink);
      
    }).catch(err => {
      console.error('Error loading data:', err);
      document.getElementById('app').textContent = 'Failed to load data.';
    });
  </script>
<script type="module">
  import { calculateStrategyScores } from './scoring.js';

  window.calculateStrategyScores = calculateStrategyScores;
</script>

  
</body>
</html>
